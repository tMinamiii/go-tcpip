トップページ - 翻訳ドキュメント - RFC 791

原文：ftp://ftp.rfc-editor.org/in-notes/rfc791.txt
原文との対訳として読みたい方へ：このページをローカルに保存して、スタイルシートの original クラスの display 属性を none から block に変更してみてください。

ソーシャルブックマーク： このページをはてなブックマークに追加 このページをDeliciousに登録 このページをlivedoorクリップに登録
サイト内関連リンク：RFC 792 ICMP(日本語訳)/RFC 768 UDP(日本語訳)/RFC 1332 IPCP(日本語訳)/RFC 4301 IPsec(日本語訳)

INTERNET PROTOCOL
DARPA INTERNET PROGRAM

PROTOCOL SPECIFICATION

September 1981

prepared for

Defense Advanced Research Projects Agency
Information Processing Techniques Office
1400 Wilson Boulevard
Arlington, Virginia 22209

by

Information Sciences Institute
University of Southern California
4676 Admiralty Way
Marina del Rey, California 90291

目次
前置き
1．導入
1.1 動機
1.2 範囲
1.3 インターフェイス
1.4 動作
2． 概観
2.1 他のプロトコルとの関係
2.2 動作モデル
2.3 機能説明
2.4 ゲートウェイ
3． 仕様
3.1 インターネットヘッダのフォーマット
3.2 考察
3.3 インターフェイス
付録 A：例とシナリオ
付録 B：データ転送順序
用語集
参考文献
前置き
この文書は DoD 標準インターネットプロトコルを規定する。この文書は ARPA インターネットプロトコル仕様の既存の 6 つの文書を元にしており、文章の多くはそれらから引用されている。構想と文章とに関して、多くの貢献者がいた。このバージョンは、アドレッシング・エラー処理・オプションコードの解釈・セキュリティ・優先順位・インターネットプロトコルの制限機能の扱いを改定する。

Jon Postel
Editor

RFC: 791
Replaces: RFC 760
IENs 128, 123, 111,
80, 54, 44, 41, 28, 26

INTERNET PROTOCOL
DARPA INTERNET PROGRAM
PROTOCOL SPECIFICATION

1. 導入
1.1. 動機
インターネットプロトコルは、パケット交換方式のコンピュータ通信ネットワークで相互接続しているシステムにおいて使用されることを目的に設計されている。このようなシステムは "catanet"[1] と呼ばれていた。インターネットプロトコルはデータグラムと呼ばれるデータブロックを送信元から宛先へと転送する方法を提供する。ここで送信元と宛先とは、固定長のアドレスによって識別されるホストである。またインターネットプロトコルは、"小さいパケット(small packet)" のネットワークを通して通信するために必要であれば、長いデータグラムを分割および再構築する方法も提供する。

1.2. 範囲
インターネットプロトコルは、ネットワークで相互接続されたシステムを通して送信者から受信者へとビットのかたまり(インターネットデータグラム)を配送するために必要とされる機能を提供するために、範囲が特に制限されている。エンドツーエンドのデータの信頼性を上げるためのメカニズム、フロー制御、順序付け、その他のホスト-ホスト間のプロトコルで一般的に見られるサービスはない。さまざまな種類/品質のサービスを提供するために、インターネットプロトコルは自身の提供するネットワークのサービスを利用することができる。

1.3. インターフェイス
このプロトコルはインターネット環境におけるホスト-ホスト間のプロトコルによって呼び出される。インターネットデータグラムを次のゲートウェイや宛先ホストへと運ぶために、このプロトコルはローカルネットワークプロトコルを呼び出す。

例えば TCP モジュールは、インターネットデータグラムのデータ部として TCP セグメント(TCP のヘッダとユーザーデータとを含む)を置くために、インターネットモジュールを呼び出すだろう。その呼び出しの引数として、TCP モジュールはインターネットモジュールに対しインターネットヘッダ内のアドレスと他のパラメータとを提供するたろう。次にインターネットモジュールはインターネットデータグラムを生成し、そのインターネットデータグラムを転送するためにローカルネットワークのインターフェイスを呼び出すだろう。

例えば APRANET の場合、インターネットモジュールは、IMP へ転送される ARPANET メッセージを生成するインターネットデータグラムに 1822 leader [2] を追加するローカルネットモジュールを呼び出すだろう。ARPANET アドレスはローカルネットワークインターフェイスによってインターネットアドレスから取得され、APRANET 内のホストのアドレスになるだろう。そのホストは他のネットワークへのゲートウェイかもしれない。

1.4. 動作
インターネットプロトコルは 2 つの基本機能、アドレス指定とフラグメント化とを提供する。

インターネットモジュールはインターネットデータグラムを宛先へと転送するために、インターネットヘッダ内にあるアドレスを使用する。転送のための経路選択はルーティングと呼ばれる。

インターネットモジュールは、"小さいパケット(small packet)" のネットワークを通して通信するのに必要であれば、インターネットヘッダ内のフィールドを使用してインターネットデータグラムを分割・再構築する。

この動作のモデルは、インターネット通信に参加している各ホストとネットワークを相互接続する各ゲートウェイとに、インターネットモジュールが存在するというものである。それらのモジュールは、アドレスフィールドの解釈とインターネットデータグラムの分割・再構成とに関する一般的な規則を共有する。加えてこれらのモジュールは(特にゲートウェイにおいて)、ルーティングを決定するなどの機能を持つ。

インターネットプロトコルは各インターネットデータグラムを他のインターネットデータグラムとは無関係の独立した実体として扱う。関連も論理回路も存在しない(仮想でもそれ以外でも)。

インターネットプロトコルはサービスを提供するために 4 つの重要なメカニズムを使用する：サービス種別(Type of Service)、有効期間(Time to Live)、オプション(Options)、ヘッダチェックサム(Header Checksum)である。

サービス種別(Type of Service)は希望するサービス品質を示すために使用される。サービス種別は、インターネットを構成するネットワークにおいて提供されるサービスの選択を特徴づけるパラメータの、抽象的または汎用的な集合である。このサービス種別の指定は、ゲートウェイが特定のネットワークのための実際の転送パラメータや、次ホップに使用されるネットワーク、インターネットデータグラムをルーティングする場合の次のゲートウェイなどを選択するために使用される。

有効期間(Time to Live)はインターネットデータグラムの寿命の上限を表す。この値は送信者によってセットされ、経路上で処理されるたびに減らされていく。インターネットデータグラムが送信先に届く前に有効期間の値がゼロになった場合、そのインターネットデータグラムは破棄される。有効期間は自爆までのタイムリミットと考えることができる。

オプション(Options)は、ごく一般的な通信には不要だが一部の状況で必要とされる制御機能を提供する。このオプションにはタイムスタンプやセキュリティ、特殊なルーティングが含まれる。

ヘッダチェックサム(Header Checksum)は、インターネットデータグラムの処理に使用された情報が正しく転送されたことの検証を提供する。データはエラーを含んでいる可能性がある。ヘッダチェックサムが間違っている場合、エラーを検出した実体によってそのインターネットデータグラムは即座に破棄される。

インターネットプロトコルは信頼できる通信機能を提供しない。エンドツーエンド(ent-to-end)でもホップバイホップ(hop-by-hop)でも受信確認は行われない。エラー制御は無く、あるのはヘッダチェックサムだけである。再送信もないし、フロー制御もない。

検出されたエラーは、インターネットプロトコルのモジュール内に実装された Internet Control Message Protocol (ICMP) [3] を通して報告されてよい。

2. 概観
2.1. 他のプロトコルとの関係
以下の図は、プロトコル階層におけるインターネットプロトコルの位置付けを示している：

                 +------+ +-----+ +-----+     +-----+
                 |Telnet| | FTP | | TFTP| ... | ... |
                 +------+ +-----+ +-----+     +-----+
                       |   |         |           |
                      +-----+     +-----+     +-----+
                      | TCP |     | UDP | ... | ... |
                      +-----+     +-----+     +-----+
                         |           |           |
                      +--------------------------+----+
                      |    Internet Protocol & ICMP   |
                      +--------------------------+----+
                                     |
                        +---------------------------+
                        |   Local Network Protocol  |
                        +---------------------------+

                           プロトコル関連図

                                 図 1.
インターネットプロトコルは一方で上位レベルのホスト間プロトコルと接続し、もう一方でローカルネットワークプロトコルと接続している。この文脈における "ローカルネットワーク(local network)" は、ビルの中の小規模なネットワークから ARPANET のような大規模なネットワークまでを意味する。

動作モデル
あるアプリケーションから別のアプリケーションへとデータグラムを送信する場合の動作モデルは、以下のようなシナリオで説明される：

この通信には中間ゲートウェイがひとつ含まれると仮定する。

送信側アプリケーションプログラムはデータを準備し、それをデータグラムとして送信するために自身のローカルのインターネットモジュールを呼び出し、その引数として宛先アドレスなどのパラメータを渡す。

インターネットモジュールはデータグラムのヘッダを準備し、それにデータを付加する。インターネットモジュールは、その宛先インターネットアドレスに必要となるローカルネットワークアドレスを判断する。このケースではこれはゲートウェイのアドレスになる。インターネットモジュールはデータグラムとローカルネットワークアドレスとをローカルネットワークインターフェイスに送信する。

ローカルネットワークインターフェイスはローカルネットワークのヘッダを生成し、それにデータグラムを付加したデータをローカルネットワーク経由で送信する。

データグラムはローカルネットワークヘッダに包まれた状態でゲートウェイホストに到達する。ローカルネットワークインターフェイスはそのヘッダを取り除き、中のデータグラムをインターネットモジュールに引き渡す。インターネットモジュールはそのインターネットアドレスから、そのデータグラムが第二のネットワーク上の別のホストへと転送されるべきであることを知る。インターネットモジュールは宛先ホストのローカルネットアドレスを判断し、データグラムを送信するためにそのネットワークのためのローカルネットワークインターフェイスを呼び出す。

ローカルネットワークインターフェイスはローカルネットワークのヘッダを生成し、それにデータグラムを付加し、宛先ホストに送信する。

宛先ホストにおいて、ローカルネットワークインターフェイスはローカルネットのヘッダを取り除き、データグラムをインターネットモジュールに引き渡す。

インターネットモジュールは、そのデータグラムがそのホスト上のアプリケーションに向けられたものであることを見つけ出す。インターネットモジュールはシステムコールに応えてアプリケーションプログラムにデータを渡し、呼び出しの結果として送信元アドレスなどのパラメータを引き渡す。

   アプリケーション                                      アプリケーション
   プログラム                                            プログラム
         |                                                   /
     インターネット          インターネット         インターネット
     モジュール              モジュール             モジュール
             |                 /       |                /
             LNI-1          LNI-1      LNI-2         LNI-2
                |           /             |          /
           ローカルネットワーク 1     ローカルネットワーク 2



                                転送経路

                                  図 2
2.3. 機能説明
インターネットプロトコルの機能または目的は、相互接続されたネットワークの集合を通してデータグラムを移動させることである。これは、あるインターネットモジュールから別のインターネットモジュールへと、目的地に到達するまでデータグラムを引き渡していくことで実現される。インターネットモジュールはインターネットシステム内のホスト上やゲートウェイ上に存在する。データグラムはインターネットアドレスの解釈に基づき、個々のネットワークを通して、あるインターネットモジュールから別のインターネットモジュールへとルーティングされる。したがってインターネットプロトコルの重要なメカニズムのひとつは、インターネットアドレスである。

あるインターネットモジュールから別のインターネットモジュールへとメッセージをルーティングするとき、最大パケットサイズがそのデータグラムのサイズより小さいネットワークを横断しなければならない可能性がある。この問題を解決するために、インターネットプロトコルはフラグメント化のメカニズムを提供する。

アドレス指定
名前・アドレス・経路[4]で区別される。名前は私たちが見るものである。アドレスはそれがどこにあるのかを表す。経路はそこに到達する方法を表す。インターネットプロトコルは主としてアドレスを扱う。名前からアドレスへのマッピングは、上位レベルのプロトコル(すなわちホスト間プロトコルまたはアプリケーションプロトコル)の仕事である。
アドレスは 4 オクテット(32 ビット)の固定長である。アドレスはネットワーク番号で始まり、その後にローカルアドレス("rest(残りの)" フィールドと呼ばれる)が続く。インターネットアドレスには 3 つのフォーマットまたはクラスがある：クラス A - 上位ビットがゼロ、次の 7 ビットがネットワーク、残りの 24 ビットがローカルアドレス。クラス B - 上位 2 ビットが 1 - 0、次の 14 ビットがネットワーク、残りの 16 ビットがローカルアドレス。クラス C - 上位 3 ビットが 1 - 1 - 0、次の 21 ビットがネットワーク、残りの 8 ビットがローカルアドレス。
インターネットアドレスをローカルネットアドレスにマッピングする際には注意しなければならない。物理的には単一のホストが複数の異なるインターネットアドレスを使用することで、複数の別々のホストであるかのように振る舞うことができるはずである。さらに一部のホストは、複数の物理的インターフェイスを持っている(マルチホーム)可能性がある。
つまり、一台のホストが複数の物理的インターフェイスを持ち、それぞれのインターフェイスに複数の論理的なインターネットアドレスを持つ場合の対策を立てておかなければならないということである。
アドレスのマッピングの例は "Address Mappings" [5] に見つけられるだろう。
フラグメンテーション
インターネットデータグラムのフラグメント化は、大きいパケットサイズを許可しているローカルネットから発信されたデータが、宛先に到達するために小さいパケットサイズに制限されているローカルネットを横断しなければならない場合に必要とされる。
インターネットデータグラムには "don't fragment(フラグメント不可)" というマークをつけることができる。そのようなマークを付けられたインターネットデータグラムは、どのような条件であってもフラグメント化されることはない。フラグメント不可とマークされたインターネットデータグラムがフラグメント化せずには宛先へ到達できないとき、そのデータグラムは破棄される。
インターネットプロトコルモジュールから見えない範囲でローカルネットワークを横断するフラグメント化・転送・再構築はイントラネットフラグメンテーションと呼ばれ、使用されてもよい[6]。
インターネットのフラグメント化と再構築の手続きは、後に再構築可能なほぼ任意の数のフラグメントにデータグラムを分割できる必要がある。フラグメントの受信者は、異なるデータグラムのフラグメントが混在しないことを保証するために識別フィールド(identification field)を使用する。フラグメントオフセットフィールド(fragment offset field)は受信者に、元のデータグラム内におけるそのフラグメントの位置を教える。フラグメントのオフセットとレングスとにより、そのフラグメントが元のデータグラム内に占めていた部分がわかる。 モアフラグメント(more-fragments)フラグは(それがリセットされることで)、最後のフラグメントを表す。これらのフィールドはデータグラムを再構築するのに十分な情報を提供する。
識別フィールドは、あるデータグラムのフラグメントを別のデータグラムのフラグメントから区別するために使用される。インターネットデータグラムの発信側プロトコルモジュールは、そのデータグラムがインターネットシステム内に存在する間、この識別フィールドに送信元-送信先の組およびプロトコルに対して一意な値をセットしなければならない。完結するデータグラムを発信するプロトコルモジュールは、モアフラグメントフラグにゼロ、フラグメントオフセットにゼロをセットする。
インターネットデータグラムを分割するために、(例えばゲートウェイ内部の)インターネットプロトコルモジュールは、新しいインターネットデータグラムを二つ生成し、それらのヘッダフィールドに元の長いデータグラムのインターネットヘッダフィールドの内容をコピーする。元の長いデータグラムのデータ部は 8 オクテット(64 ビット)境界で二つの部分に分割される(後半部分のサイズは 8 オクテットの整数倍ではないかもしれないが、前半部分はそうでなければならない)。最初のフラグメントの 8 オクテットブロック数を NFB(Number of Fragment Blocks)と呼ぶ。最初のフラグメントは第一の新しいインターネットデータグラム内に置かれ、全長フィールド(total length field)には最初のフラグメントの長さがセットされ、モアフラグメントフラグには 1 がセットされる。第二のフラグメントは二番目の新しいインターネットデータグラム内に置かれ、全長フィールド(total length field)には二番目のデータグラムの長さがセットされ、モアフラグメントフラグは元の長いデータグラムと同じ値がセットされる。二番目の新しいインターネットデータグラムのフラグメントオフセットフィールドには、元の長いデータフィールドの同じフィールドの値に NFB を加えた値がセットされる。
この手続きは上記の 2 分割ではなく、n 分割に一般化することができる。
インターネットダイアグラムのフラグメントを再構築するために、(例えば宛先ホスト上の)インターネットプロトコルモジュールは、識別(identification)・送信元(source)・宛先(destination)・プロトコル(protocol)の 4 つのフィールドがすべて同じ値のインターネットデータグラムを結合する。この結合は、各フラグメントのヘッダ内のフラグメントオフセットに示されている相対位置に各フラグメントのデータ部分を配置することで行われる。先頭のフラグメントのオフセットはゼロになる。最後のフラグメントのモアフラグメントフラグはゼロに初期化される。
2.4. ゲートウェイ
ゲートウェイはネットワーク間でデータグラムを転送するためにインターネットプロトコルを実装する。またゲートウェイは、ルーティングや他のネットワーク間制御情報を調整するためにゲートウェイ間プロトコル(GGP) [7] も実装する。

ゲートウェイ内に上位プロトコルを実装する必要はなく、GGP 機能は IP モジュールに追加される。

                   +-------------------------------+
                   | Internet Protocol & ICMP & GGP|
                   +-------------------------------+
                           |                 |
                 +---------------+   +---------------+
                 |   Local Net   |   |   Local Net   |
                 +---------------+   +---------------+

                        ゲートウェイプロトコル群

                                 図 3
3. 仕様
3.1. インターネットヘッダのフォーマット
インターネットヘッダの概要は以下の通り：

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Version|  IHL  | Type of Service|          Total Length         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Identification        |Flags|      Fragment Offset    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Time to Live |    Protocol   |         Header Checksum       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       Source Address                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Destination Address                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Options                    |    Padding    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                 インターネットデータグラムのヘッダの例

                                 図 4
1 目盛りが 1 ビットを表していることに注意してほしい。

Version(バージョン): 4 ビット
Version フィールドはインターネットヘッダのフォーマットを表す。この文書はバージョン 4 について記述している。
IHL: 4 ビット
Internet Header Length はインターネットヘッダの長さを 32 ビットワード値で表したものであり、したがってデータの開始位置を指している。正しいヘッダであれば最低でも 5 となる。
Type of Service(サービス種別)： 8 ビット
Type of Service は、望まれるサービス品質の抽象的パラメータの指定を提供する。これらのパラメータは、特定のネットワークを通してデータグラムを送信するときに実際のサービスパラメータの選択を誘導するものである。一部のネットワークはサービスの優先順位付けを提供しており、何らかの方法で重要なトラフィックを優先順位の高いものをとして扱う(一般的には高負荷時に特定の優先順位以上のトラフィックだけを受け付けることで実現される)。選択に重要となるのは、低遅延・高信頼性・高スループットという三者間のトレードオフである。
    Bits 0-2:  優先度(Precedence)
    Bit    3:  0 = 通常の遅延              1 = 低遅延
                   (Normal Delay)              (Low Delay)
    Bits   4:  0 = 通常のスループット      1 = 高スループット
                   (Normal Throughput)         (High Throughput)
    Bits   5:  0 = 通常の信頼性            1 = 高信頼性
                   (Normal Reliability)        (High Reliability)
    Bit  6-7:  将来のために予約済み

       0     1     2     3     4     5     6     7
    +-----+-----+-----+-----+-----+-----+-----+-----+
    |                 |     |     |     |     |     |
    |   PRECEDENCE    |  D  |  T  |  R  |  0  |  0  |
    |                 |     |     |     |     |     |
    +-----+-----+-----+-----+-----+-----+-----+-----+

      優先度(Precedence)

          111 - ネットワーク制御(Network Control)
          110 - ネットワーク間制御(Internetwork Control)
          101 - CRITIC/ECP
          100 - 瞬時より優先(Flash Override)
          011 - 瞬時(Flash)
          010 - 即時(Immediate)
          001 - 優先(Priority)
          000 - 通常(Routine)
遅延・スループット・信頼性の指定は、サービスの(何らかの意味の)コストを増加させる可能性がある。多くのネットワークでは、これらのパラメータのどれかひとつのパフォーマンスを上げることは、残り二つのパラメータのパフォーマンスを落とすことに繋がる。きわめて特殊な状況を除き、これら三つのパラメータのうち多くとも二つだけをセットする(1 にする)べきである。
Type of Service は、インターネットシステムを通して転送される間のデータグラムの扱いを指定するために使用される。インターネットのサービス種別を AUTODIN II や ARPANET、SATNET、PRNET などのネットワーク上の実際のサービスにマッピングする例は、"Service Mappings" [8] に示されている。
ネットワーク制御という優先度の指定は、ネットワーク内でのみ使用されることを意図している。この指定の実際の使用法と制御は、各ネットワークに依存する。ネットワーク間制御の指定は、ゲートウェイ制御の発信者によってのみ使用されることを意図している。これらの優先度の指定が特定のネットワークに対してのみ向けられたものである場合、それらの優先度の指定へのアクセスと使用との制御は、そのネットワークの責任である。
Total Length(全長)： 16 ビット
Total Length はデータグラムの長さであり、インターネットヘッダとデータとを含み、オクテット単位で表される。このフィールドが許可する最大長は 65,535 オクテットである。そのような長いデータグラムは、ほとんどのホストやネットワークにとって非現実的なものである。すべてのホストは、(全体としてでもフラグメントとしてでも) 576 オクテット以下のデータグラムを受け入れる準備が出来ていなければならない。576 オクテットより大きいデータグラムを送信するホストは、送り先がそのような長いデータグラムを受け入れる準備ができていることを確認した場合にのみ、それを送信することが推奨される。
この 576 という値は、必須のヘッダ情報に加えて、合理的なサイズのデータブロックの転送を可能にするために選ばれている。例えばこのサイズは、512 オクテットのデータブロックと 64 オクテットのヘッダとをひとつのデータグラムに納めることを可能にする。インターネットヘッダの最大長は 60 オクテット、典型的なインターネットヘッダは 20 オクテットであり、上位レベルプロトコルのヘッダに対する余裕を持たせている。
Identification(識別)： 16 ビット
データグラムのフラグメントを再構築するのを手助けするために、送信者によって割り当てられる識別値である。
Flags(フラグ)： 3 ビット
種々の制御フラグ(Various Control Flags)。
  Bit 0: 予約済み。ゼロでなければならない。
  Bit 1: (DF) 0 = フラグメント化されてよい
                  (May Fragment)
              1 = フラグメント化しない
                  (Don't Fragment)
  Bit 2: (MF) 0 = 最後のフラグメント
                  (Last Fragment)
                  1 = 途中のフラグメント
                  (More Fragments)

          0   1   2
        +---+---+---+
        |   | D | M |
        | 0 | F | F |
        +---+---+---+
Fragment Offset(フラグメントオフセット)： 13 ビット
このフィールドは、データグラム内でこのフラグメントが占める位置を表す。フラグメントオフセットは 8 オクテット(64 ビット)単位で示される。先頭のフラグメントのオフセットはゼロである。
Time to Live(有効期間): 8 ビット
このフィールドは、このデータグラムがインターネットシステム上にとどまることを許される最大時間を表す。このフィールドの値がゼロの場合、そのデータグラムは破棄されなければならない。このフィールドはインターネットヘッダの処理中に変更される。時間は秒単位で表されるが、TTL はデータグラムの存在可能な上限時間であると考えなければならない。なぜなら、データグラムを処理するすべてのモジュールは、1 秒以内にその処理が終わったとしても、TTL を少なくとも 1 秒は減らさなければならないためである。この目的は、配送不可能なデータグラムの破棄と、データグラムの寿命を制限することである。
Protocol(プロトコル)： 8 ビット
このフィールドは、インターネットデータグラムのデータ部に使用されている上位レベルプロトコルを表す。"Assigned Numbers" [9] において、様々なプロトコルのための値が規定されている。
Header Checksum(ヘッダチェックサム)： 16 ビット
ヘッダのみに対するチェックサムである。一部のヘッダフィールド(例えば TTL)は変化するため、インターネットヘッダが処理されるごとに再計算と検証が行われる。
チェックサムアルゴリズムは以下の通り：
チェックサムフィールドは、ヘッダ内の全ての 16 ビットワードの補数の合計に対する 16 ビットの補数である。チェックサムを計算する際には、チェックサムフィールドの値をゼロとみなす。
このチェックサムの計算は単純で経験的にも適切なことが示されているが、これは暫定的なものであり、より経験を重ねることで CRC 手続きに置き換えられてもよい。
Source Address(送信元アドレス)： 32 ビット
送信元アドレス。セクション 3.2 を参照してほしい。
Destination Address(宛先アドレス)： 32 ビット
宛先アドレス。セクション 3.2 を参照してほしい。
Options(オプション)： 可変長
データグラムにおいてオプションは現れても現れなくてもよい。すべての IP モジュール(ホスト・ゲートウェイ)はオプションを実装しなければならない。特定のデータグラムにおけるそれらの転送がオプションなのであって、その実装がオプションなのではない。
環境によっては、すべてのデータグラムにセキュリティオプションが必須かもしれない。
オプションフィールドは可変長である。0 個または複数のオプションが許可される。オプションの書式には 2 つのケースがある：
ケース 1： 単一オクテットの option-type。
ケース 2： option-type オクテットと option-length オクテットと、実際の option-date オクテット。
option-length オクテットは、option-date オクテットだけでなく、option-type オクテットと option-length オクテットも含めてカウントする。
option-type オクテットは 3 つのフィールドを持っているとみなされる：
      1 ビット  コピーフラグ
      2 ビット  オプションクラス
      5 ビット  オプション番号
コピーフラグは、フラグメント化されたすべてのフラグメントにそのオプションがコピーされていることを示す。
      0 = コピーされていない(not copied)
      1 = コピーされている(copied)
オプションクラスは以下の通り：
      0 = 制御
      1 = 将来のために予約済み
      2 = デバッグと計測
      3 = 将来のために予約済み
以下のインターネットオプションが定義済みである：
  クラス 番号   長さ  説明
  ------ ------ ----- -----------
    0     0      -    オプションリスト終了。このオプションは
                      1 オクテットしか使用せず、長さを持たない。
    0     1      -    ノーオペレーション。このオプションは
                      1 オクテットしか使用せず、長さを持たない。
    0     2     11    セキュリティ。DOD の要求事項と互換性のある
                      セキュリティ、区分、ユーザーグループ(TCC)、
                      取り扱い制限コードを送信するために使用される。
                      (訳注：DOD＝米国国防総省)
    0     3     可変  ルーズソースルーティング。送信元の提供する
                      情報に基づいてインターネットデータグラムを
                      ルーティングするために使用される。
    0     9     可変  ストリクトソースルーティング。送信元の提供
                      する情報に基づいてインターネットデータグラ
                      ムをルーティングするために使用される。
    0     7     可変  経路記録。インターネットデータグラムが通っ
                      た経路を追跡するために使用される。
    0     8      4    ストリーム ID。ストリーム識別子を送信するた
                      めに使用される。
    2     4     可変  インターネットタイムスタンプ。
具体的なオプションの定義
オプションリスト終了
        +--------+
        |00000000|
        +--------+
         タイプ=0
このオプションはオプションリストの終了を表す。これはインターネットヘッダ長から知ることのできるインターネットヘッダの終了と一致しない可能性がある。これは各オプションの終わりではなく、すべてのオプションの終端に使用され、オプションの終端がインターネットヘッダの終端と一致しない場合にのみ必要である。

フラグメント化またはその他の理由でコピー・導入・削除されてよい。

ノーオペレーション
        +--------+
        |00000001|
        +--------+
         タイプ=1
このオプションは、オプションの間に置くことで、例えば後続のオプションの開始位置を 32 ビット境界にそろえるために使用される。

フラグメント化またはその他の理由でコピー・導入・削除されてよい。

セキュリティ
このオプションは、セキュリティ・区分・取り扱い制限・TCC(クローズドユーザーグループ)パラメータをホストが送信する方法を提供する。このオプションのフォーマットは以下の通り：

          +--------+--------+---//---+---//---+---//---+---//---+
          |10000010|00001011|SSS  SSS|CCC  CCC|HHH  HHH|  TCC   |
          +--------+--------+---//---+---//---+---//---+---//---+
         タイプ=130 レングス=11
セキュリティ(Security) (S フィールド): 16 ビット
16 段階のセキュリティのひとつを指定する(8 個は将来のために予約されている)
            00000000 00000000 - Unclassified(機密扱いではない)
            11110001 00110101 - Confidential(秘密)
            01111000 10011010 - EFTO
            10111100 01001101 - MMMM
            01011110 00100110 - PROG
            10101111 00010011 - Restricted(部外秘)
            11010111 10001000 - Secret(機密)
            01101011 11000101 - Top Secret(極秘)
            00110101 11100010 - (将来のために予約済み)
            10011010 11110001 - (将来のために予約済み)
            01001101 01111000 - (将来のために予約済み)
            00100100 10111101 - (将来のために予約済み)
            00010011 01011110 - (将来のために予約済み)
            10001001 10101111 - (将来のために予約済み)
            11000100 11010110 - (将来のために予約済み)
            11100010 01101011 - (将来のために予約済み)
区分(Compartments) (C フィールド): 16 ビット
送信する情報が区分けされたものでなければ、すべてゼロの値を使用する。区分フィールドのそれ以外の値は米国防情報局から取得できる。
取り扱い制限(Handling Restrictions) (H フィールド): 16 ビット
制御と解放とを表す値は英数字の連字であり、米国防情報局の Manual DIAM 65-19 "Standard Security Markings" で定義されている。
通信制御コード(Transmission Control Code) (TCC フィールド)
加入者間で興味のあるトラフィックを分離し、管理コミュニティを定義するための手段を提供する。TCC の値は、HQ DCA Code 530 より入手可能な三重文字である。
フラグメント化時にはコピーされなければならない。このオプションはひとつのデータグラムに高々一回だけ現れる。
ルーズソースルーティングおよび経路記録
        +--------+--------+--------+---------//--------+
        |10000011|レングス|ポインタ|      経路情報     |
        +--------+--------+--------+---------//--------+
        タイプ=131
ルーズソースルーティングおよび経路記録(LSRR)オプションは、インターネットデータグラムの送信元が、宛先へのデータグラム転送時にゲートウェイが使用し経路情報を記録するためルーティング情報を提供する。

このオプションはオプションタイプコードから始まる。第二オクテットはオプションの長さであり、これにはオプションタイプコード、レングス(length)オクテット、ポインタ(pointer)オクテット、(レングス - 3)の経路情報オクテットが含まれる。第三オクテットは、経路情報の中で次に処理されるべき送信元アドレスのオクテット位置を指すポインタである。ポインタはこのオプションからの相対的な値である。したがって正しい値であれば最小でも 4 となる。

経路情報は一連のインターネットアドレスから構成される。各インターネットアドレスは 32 ビットまたは 4 オクテットである。ポインタがレングスよりも大きい場合、ソースルートは空(かつ経路記録が満杯)ということであり、ルーティングは宛先アドレスフィールドに基づいて行われる。

宛先アドレスフィールドのアドレスに到達し、かつポインタがレングス以下の場合、ソースルート内の次アドレスは宛先アドレスフィールドのアドレスに置き換えられ、経路記録のアドレスは今使用した送信元アドレスに置き換えられ、ポインタは 4 だけ加算される。

経路記録に残されるアドレスは、このデータグラムが転送されてきた環境において知られているインターネットモジュール自身のインターネットアドレスである。

ソースルートを経路記録に置き換えるこの手順は(ソースルートとして使用するには順序を逆にしなければならないが)、ネットワーク間を通過してもこのオプション(および IP ヘッダ全体)の長さが変化しないことを意味する。

ゲートウェイまたはホストの IP は、経路データ上の次のアドレスに到達するために、任意の数の中間ゲートウェイによる任意の経路を使用することが許される。そのため、このオプションはルーズソースルーティングである。

フラグメント化時にはコピーされなければならない。このオプションはひとつのデータグラムに高々一回だけ現れる。

ストリクトソースルーティングおよび経路記録
        +--------+--------+--------+---------//--------+
        |10001001|レングス|ポインタ|      経路情報     |
        +--------+--------+--------+---------//--------+
        タイプ=137
ストリクトソースルーティングおよび経路記録(SSRR)は、インターネットデータグラムの送信元が、宛先へのデータグラム転送時にゲートウェイが使用し経路情報を記録するためルーティング情報を提供する。

このオプションはオプションタイプコードで始まる。第二オクテットはオプションの長さであり、これにはオプションタイプコードとレングス(length)オクテット、(レングス - 3)の経路情報オクテットが含まれる。第三オクテットは、経路情報の中で次に処理されるべき送信元アドレスのオクテット位置を指すポインタである。ポインタはこのオプションからの相対的な値である。したがって正しい値であれば最小でも 4 となる。

経路情報は一連のインターネットアドレスから構成される。各インターネットアドレスは 32 ビットまたは 4 オクテットである。ポインタがレングスより大きい場合、ソースルートは空(かつ経路記録が満杯)ということであり、ルーティングは宛先アドレスフィールドに基づいて行われる。

宛先アドレスフィールドのアドレスに到達し、かつポインタがレングス以下の場合、ソースルート内の次アドレスは宛先アドレスフィールドのアドレスに置き換えられ、経路記録のアドレスは今使用した送信元アドレスに置き換えられ、ポインタは 4 だけ加算される。

経路記録に残されるアドレスは、このデータグラムが転送されてきた環境において知られているインターネットモジュール自身のインターネットアドレスである。

ソースルートを経路記録に置き換えるこの手順は(ソースルートとして使用するには順序を逆にしなければならないが)、ネットワーク間を通過してもこのオプション(および IP ヘッダ全体)の長さが変化しないことを意味する。

ゲートウェイまたはホストの IP は、経路データ上の次のゲートウェイまたはホストに到達するために、次アドレスに示される直結したネットワークだけを通して、ソースルート上の次のアドレスにデータグラムを直接送信しなければならない。そのため、このオプションはストリクトソースルーティングである。

フラグメント化時にはコピーされなければならない。このオプションはひとつのデータグラムに高々一回だけ現れる。

経路記録
        +--------+--------+--------+---------//--------+
        |00000111|レングス|ポインタ|      経路情報     |
        +--------+--------+--------+---------//--------+
         タイプ=7
経路記録オプションは、インターネットダイアグラムの経路を記録する手段を提供する。

このオプションはオプションタイプコードで始まる。第二オクテットはオプションの長さであり、これにはオプションタイプコードとレングス(length)オクテット、ポインタオクテット、(レングス - 3)の経路情報オクテットが含まれる。第三オクテットは経路アドレスを保存するための次の領域を指すポインタである。ポインタはオプションに対して相対的な値である。したがって正しい値であれば最小でも 4 となる。

経路記録は一連のインターネットアドレスから構成される。各インターネットアドレスは 32 ビットまたは 4 オクテットである。ポインタがレングスより大きい場合、経路記録が満杯ということである。送信元ホストは、予想されるすべてのアドレスを保持するのに十分な経路情報領域を持たせてこのオプションを作成しなければならない。このオプションのサイズはアドレスの追加では変化しない。経路情報の初期値はゼロでなければならない。

データグラムを中継するとき、インターネットモジュールは経路記録オプションが付加されているかどうかを確認する。もし付加されていれば、インターネットモジュールは自身のインターネットアドレスをポインタで指定されたオクテット位置に挿入し、ポインタに 4 を加算する。ここで挿入されるインターネットアドレスは、データグラムが転送されてきた環境において知られているアドレスである。

経路情報の領域が満杯の場合(つまりポインタ位置がレングスを超えている場合)、データグラムは転送されるが経路情報は記録されない。空き領域はあるもののアドレス全体を含めるには不足している場合、元のデータグラムはエラーと見なされ、破棄される。どちらの場合も送信元ホストに ICMP パラメータエラーメッセージが送信されてよい[3]。

フラグメント化時にコピーされず、先頭フラグメントにのみ現れる。このオプションはひとつのデータグラムに高々一回だけ現れる。

ストリーム識別子
        +--------+--------+--------+--------+
        |10001000|00000010|  ストリーム ID  |
        +--------+--------+--------+--------+
        タイプ=136 レングス=4

        (訳注：レングスの「00000010」は「00000100」の誤りと思われます。)
このオプションは、ストリームの概念をサポートしないネットワークを通して、16 ビットの SATNET ストリーム識別子を伝達する方法を提供する。

フラグメント化時にコピーされなければならない。このオプションはひとつのデータグラムに高々一回だけ現れる。

インターネットタイムスタンプ
        +--------+--------+--------+--------+
        |01000100|レングス|ポインタ|oflw|flg|
        +--------+--------+--------+--------+
        |      インターネットアドレス       |
        +--------+--------+--------+--------+
        |          タイムスタンプ           |
        +--------+--------+--------+--------+
        |                 .                 |
                          .
                          .
        タイプ = 68
このオプションのレングスは、タイプ・レングス・ポインタ・オーバーフロー/フラグ(oflw|flg)のオクテット数である(最大長 40)。

ポインタは、このオプションの先頭からタイムスタンプの終端までのオクテット数に 1 を加えた値である(つまり次のタイムスタンプを置く領域の先頭を指す)。正常な場合の最小値は 5 である。ポインタの値がレングスよりも大きい場合、タイムスタンプの領域が満杯であることを表す。

オーバーフロー(oflw) [4 ビット]は、領域不足のためにタイムスタンプを登録できなかった IP モジュールの数である。

フラグ(flg) [4 ビット]の値は以下の通り：

0 -- タイムスタンプのみ。連続する 32 ビットワード内に保存される。
1 -- 各タイムスタンプの前に、それを登録した実体のインターネットアドレスが置かれる。
3 -- インターネットアドレスは事前に指定されている。次に指定されているアドレスと自身のアドレスとが一致する場合にのみ、IP モジュールはタイムスタンプを登録する。
タイムスタンプは右詰めの 32 ビットタイムスタンプであり、UT の深夜零時からの経過ミリ秒を表す。ミリ秒単位を利用できない場合、または UT の深夜零時からの経過時間を提供できない場合、非標準の値が使用されていることを表すためにタイムスタンプフィールドの上位 1 ビットをセットすることを条件に、任意の時刻をタイムスタンプとして挿入することができる。

発信ホストは、予期されるすべてのタイムスタンプ情報を保持するのに十分な領域を持たせてこのオプションを生成しなければならない。このオプションのサイズがタイムスタンプの追加によって変更されることはない。タイムスタンプ情報の初期内容は、ゼロ、またはインターネットアドレス/ゼロの組でなければならない。

タイムスタンプ用の領域がすでに一杯の場合(ポインタがレングスを超えている場合)、データグラムは転送されるが、タイムスタンプは挿入されず、オーバーフローカウントが 1 加算される。

空き領域はあるものの完全なタイムスタンプを挿入するには不足している場合、またはオーバーフローカウント自体がオーバーフローする場合、そのデータグラムはエラーと見なされ、破棄される。いずれの場合も、送信元ホストに ICMP パラメータ障害メッセージが送信されてよい[3]。

タイムスタンプオプションはフラグメント化時にコピーされず、先頭のフラグメント内に含まれる。このオプションはひとつのデータグラムに高々一回だけ現れる。

パディング: 可変
インターネットヘッダのパディングは、ヘッダが 32 ビット境界で終了するのを保証するために使用される。パディングの内容はゼロである。
3.2. 考察
プロトコル実装は堅牢でなければならない。各実装は、様々な個人が作成した別の実装と相互運用できることを期待されるだろう。本仕様の目的はこのプロトコルを明確化することであるが、異なった解釈をされる可能性もある。一般に実装は、送信時の振る舞いは保守的で、受信時の振る舞いは寛容でなければならない。言い換えると、実装は的確なデータグラムを送信するべきであり、また解釈可能なデータグラムは全て受け入れるべきである(例えば、技術的にはエラーでも意図が明確であればエラーにしないべきである)。

基本的なインターネットサービスはデータグラム指向であり、ゲートウェイでのフラグメンテーションを提供し、宛先ホスト上のインターネットプロトコルモジュールで再構築される。もちろん、インターネットプロトコルおよび上位プロトコルに対して透過的である限り、ネットワーク内またはネットワークのゲートウェイ間のプライベートな合意によるデータグラムのフラグメンテーション・再構築は許される。この透過型のフラグメンテーション・再構築は "ネットワーク依存(network-dependent)" (または イントラネット) のフラグメンテーションと呼ばれるもので、ここではこれ以上議論しない。

インターネットアドレスは送信元と宛先とをホストレベルで識別し、その上でプロトコルフィールドを提供する。各プロトコルはあるホスト内において必要とされるどのような多重化でも提供すると見なされる。

アドレッシング
ネットワークへのアドレス割り当てにおける柔軟性を提供し、かつ小規模から中規模の多数のネットワークを可能にするために、アドレスフィールドの解釈は、ホスト数の多い少数のネットワーク、ホスト数が中程度で中程度の数のネットワーク、ホスト数の少ない多数のネットワークを特定するようにコード化されている。さらに、拡張アドレッシングモードのためのエスケープコードも存在する。
    アドレスフォーマット：

      上位ビット  フォーマット                                クラス
      ----------  ------------------------------------------  -----
          0        7 ビットがネットワーク、24 ビットがホスト    a
          10      14 ビットがネットワーク、16 ビットがホスト    b
          110     21 ビットがネットワーク、 8 ビットがホスト    c
          111     拡張アドレッシングモードへのエスケープ
ネットワークフィールドの値が 0 の場合、そのネットワークを意味する。これは特定の ICMP メッセージにおいてのみ使用される。拡張アドレッシングモードは未定義である。これらは共に、将来のために予約されている。
ネットワークアドレスに割り当てられている実際の値は "Assigned Numbers" [9] に示されている。
ローカルネットワークによって割り当てられるローカルアドレスは、単独の物理ホストが複数の異なるインターネットホストとして振る舞うことを許可しなければならない。つまり、インターネットホストアドレスとネットワーク/ホストインターフェイスとの間で、複数のインターネットアドレスをひとつのインターフェイスに対応させられるマッピングが必ず必要ということである。また、ホストが複数の物理インターフェイスを持ち、そのうちの複数からのデータグラムが単一のホストに解決されるかのように扱うことを許可しなければならない。
インターネットアドレスと ARPANET・SATNET・PRNET・その他のネットワークのアドレスとのマッピングは、"Address Mappings" [5] に記述されている。
フラグメント化と再構築
インターネット識別フィールド(ID)は、再構築のためにデータグラムフラグメントを識別するために、送信元/宛先アドレス、プロトコルフィールドと供に使用される。
モアフラグメントフラグビット(MF)は、データグラムが最終フラグメントではない場合にセットされる。フラグメントオフセットフィールドは、フラグメント化される前のデータグラムの先頭からの相対位置を表す。フラグメントは 8 オクテット単位で計算される。フラグメント化の方針は、フラグメント化されないデータグラムがフラグメント情報にすべてゼロ(MF = 0、フラグメントオフセット = 0)を持つように設計されている。インターネットデータグラムがフラグメント化される場合、そのデータ部分は 8 オクテット境界で分割されなければならない。
このフォーマットにより、各 8 オクテットで 2**13 = 8192 個のフラグメント、計 65,536 オクテットが可能である。これはデータグラムの全長フィールドと一致していることに注意してほしい(当然ながらヘッダはフラグメントではカウントされず、全長ではカウントされる)。
フラグメント化が起こるとき、各フラグメントにコピーされるオプションと、先頭のフラグメントだけに残されるオプションとがある。
すべてのインターネットモジュールは、68 オクテットのデータグラムをフラグメント化せずに送信できなければならない。これはインターネットヘッダが最長 60 バイトであり、最小のフラグメントが 8 オクテットであるためである。
すべてのインターネット受信者は 576 オクテットのデータグラムをひとかたまりとして、または再構築されるべき複数のフラグメントとして受信できなければならない。
フラグメント化に影響される可能性のあるフィールド：
(1) オプションフィールド(options field)
(2) モアフラグメントフラグ
(3) フラグメントオフセット(fragment offset)
(4) インターネットヘッダ長フィールド(internet header length field)
(5) 全長フィールド(total length field)
(6) ヘッダチェックサム(header checksum)
ドントフラグメント(Don't Fragment)(DF) ビットがセットされている場合、そのデータグラムのフラグメント化は、たとえ破棄される可能性がある場合でも許可されない(NOT)。これは、受信ホストがフラグメントを再構築するのに十分なリソースを持っていない場合に、フラグメント化を禁止する目的で使用することができる。
ドントフラグメント機能の使用例のひとつは、小規模ホストの回線負荷を下げることである。小規模ホストは、データグラムを受け入れてメモリに保存し、それを実行するブートストラッププログラムを持つ場合がある。
フラグメント化と再構築との手続きは、例示によってもっとも容易に説明される。以下の手続きは実装例である。
以下の擬似プログラム中の一般表記：
"=<" は "以下(less than or equal)" を表す。
"#" は "等しくない(not equal)" を表す。
"=" は "等しい(equal)" を表す。
"<-" は "をセットされる(is set to)" を表す。
また、"x から y まで(x to y)" は x を含むが y を含まない。例えば "4 から 7 まで" には 4、5、6 が含まれる(7 は含まれない)。
(訳注：最後の「x to y」は「x から y(to)まで」と記述しています。)
フラグメント化手続きの例
次のネットワーク上を送信可能な最大サイズのデータグラムを、最大転送単位(MTU)と呼ぶ。
全長がこの MTU 以下であれば、そのデータグラムはデータグラム処理の次のステップに投入される。そうでなければ、二つのフラグメントに分割され、先頭のフラグメントは最大サイズになり、二番目のフラグメントはデータグラムの残りのサイズとなる。先頭のフラグメントはデータグラム処理の次のステップへと投入される一方で、二番目のフラグメントは、まだ長すぎるのであれば再びこの手続きに投入される。
表記：
        FO    -  フラグメントオフセット(Fragment Offset)
        IHL   -  インターネットヘッダ長
                 (Internet Header Length)
        DF    -  ドントフラグメントフラグ
                 (Don't Fragment flag)
        MF    -  モアフラグメントフラグ(More Fragments flag)
        TL    -  全長(Total Length)
        OFO   -  元のフラグメントオフセット
                 (Old Fragment Offset)
        OIHL  -  元のインターネットヘッダ長
                 (Old Internet Header Length)
        OMF   -  元のモアフラグメントフラグ
                 (Old More Fragments flag)
        OTL   -  元の全長(Old Total Length)
        NFB   -  フラグメントブロック数
                 (Number of Fragment Blocks)
        MTU   -  最大転送単位(Maximum Transmission Unit)

手続き：
        IF TL =< MTU THEN このデータグラムをデータグラム
             処理の次のステップに投入する ELSE IF DF = 1 THEN
               そのデータグラムを破棄する ELSE
        最初のフラグメントを生成する:
        (1)  元のインターネットヘッダをコピーする;
        (2)  OIHL <- IHL; OTL <- TL; OFO <- FO; OMF <- MF;
        (3)  NFB <- (MTU-IHL*4)/8;
        (4)  最初の NFB*8 オクテットをはめ込む;
        (5)  ヘッダを訂正する:
             MF <- 1;  TL <- (IHL*4)+(NFB*8);
             チェックサムを再計算する;
        (6)  このフラグメントをデータグラム処理の次の
             ステップに投入する;
        二番目のフラグメントを生成する:
        (7)  インターネットヘッダを選択的にコピーする
             (一部のオプションはコピーされない。
              オプション定義を参照);
        (8)  残りのデータを追加する;
        (9)  ヘッダを訂正する:
             IHL <- (((OIHL*4)-(コピーされないオプション
               の長さ))+3)/4;
             TL <- OTL - NFB*8 - (OIHL-IHL)*4);
             FO <- OFO + NFB;  MF <- OMF; チェックサムを
             再計算する;
        (10) このフラグメントをフラグメントテストに投入する;
             DONE.

上記の手続きでは、(最終フラグメントを除く)各フラグメントは許される最大サイズを取る。代替の手続きでは最大サイズ未満のデータグラムを生成してもよい。例えば、大きなデータグラムを最大転送ユニットサイズ未満になるまで繰り返し半分に分割していくフラグメント化手続きを実装することもできる。
再構築手続きの例
各データグラムごとのバッファ識別子は、送信元・宛先・プロトコル・識別フィールドの連結として算出される。これがデータグラム全体(つまりフラグメントオフセットとモアフラグメントフィールドとが共にゼロ)の場合、このバッファ識別子に関連するすべての再構築リソースは開放され、データグラムはデータグラム処理の次のステップに送られる。
このバッファ識別子を持つ他のフラグメントが手元に無い場合、再構築リソースが割り当てられる。再構築リソースは、データバッファ、ヘッダバッファ、フラグメントブロックビットテーブル、データ全長フィールド、タイマーから構成される。フラグメントからのデータはそのフラグメントのオフセットとレングスとに従ってデータバッファに置かれ、フラグメントブロックビットテーブル内の受信したフラグメントブロックに対応するビットがセットされる。
これが先頭のフラグメント(つまりフラグメントオフセットがゼロ)の場合、そのヘッダはヘッダバッファに置かれる。これが最終フラグメント(つまりモアフラグメントフィールドがゼロ)の場合、データ全長が計算される。このフラグメントがデータグラムを完成させる場合(フラグメントブロックテーブルにセットされたビットを確認することで検証される)、そのデータグラムはデータグラム処理の次のステップに送られる。そうでなければ、タイマーは現在のタイマーとそのフラグメントの有効期間フィールドの値との最大値にセットされ、再構築ルーチンは制御を中断する。
タイマーの期限が切れた場合、このバッファ識別子のための再構築リソースはすべて解放される。タイマーの初期値は再構築待機時間の下限値である。これは、到着したフラグメントの TTL が現在のタイマー値より大きい場合には待機時間が増やされるが、小さい場合には減らされるためである。このタイマーの到達できる最大値は最大の TTL である(およそ 4.25 分)。現在のタイマーの初期値の推奨は 15 秒である。この値はこのプロトコルの経験が積まれることで変更されてもよい。このパラメータ値の選択は、バッファの許容量と通信媒体のデータ転送速度とに関係する(つまり、データ転送速度 × タイマー値 ＝ バッファサイズ(10k/s X 15s = 150kb))。
表記法：
        FO    -  フラグメントオフセット(Fragment Offset)
        IHL   -  インターネットヘッダ長
                 (Internet Header Length)
        MF    -  モアフラグメントフラグ(More Fragments flag)
        TTL   -  有効期間(Time To Live)
        NFB   -  フラグメントブロック数
                 (Number of Fragment Blocks)
        TL    -  全長(Total Length)
        TDL   -  データ全長(Total Data Length)
        BUFID -  バッファ識別子(Buffer Identifier)
        RCVBT -  フラグメント受信ビットテーブル
                 (Fragment Received Bit Table)
        TLB   -  タイマー下限値(Timer Lower Bound)

手続き：
        (1)  BUFID <- source|destination|protocol|identification;
        (2)  IF FO = 0 AND MF = 0
        (3)     THEN IF BUFID のバッファが割り当て済み
        (4)             THEN この BUFID のためのすべての
                             再構築を消去する;
        (5)          データグラムを次のステップに投入する;
                     DONE.
        (6)     ELSE IF BUFID のバッファが割り当てられていない
        (7)             THEN BUFID の再構築リソースを割り当てる;
                             TIMER <- TLB; TDL <- 0;
        (8)          フラグメントのデータを、BUFID の
                     データバッファのオクテット FO*8 から
                     オクテット (TL-(IHL*4))+FO*8 まで(to)置く;
        (9)          RCVBT ビットを FO から FO+((TL-(IHL*4)+7)/8
                     まで(to)セットする;
        (10)         IF MF = 0 THEN TDL <- TL-(IHL*4)+(FO*8)
        (11)         IF FO = 0 THEN ヘッダをヘッダバッファに置く
        (12)         IF TDL # 0
        (13)          AND 0 から (TDL+7)/8 まで(to)の全 RCVBT
                          ビットがセットされている
        (14)            THEN TL <- TDL+(IHL*4)
        (15)                 データグラムを次のステップに
                             投入する;
        (16)                 この BUFID のための再構築リソースを
                             全て開放する; DONE.
        (17)         TIMER <- MAX(TIMER,TTL);
        (18)         次のフラグメントまたはタイマーの期限切れ
                     まで中断する;
        (19) タイマーの期限切れ：この BUFID のすべての
             再構築を消去する; DONE.

二つ以上のフラグメントが全体または一部重複した同じデータを含む場合、この手続きはデータバッファと配送されたデータグラムとのうち、より最近到着したコピーを使用する。
識別
データグラムのための識別子の選択は、特定のデータグラムのフラグメントを一意に識別する方法を提供する必要性に基づいている。複数のフラグメントが同じ送信元・宛先・プロトコル・識別子を持つ場合、プロトコルモジュールはそれらのフラグメントが同じデータグラムに属すると判断する。したがって送信者は、あるデータグラム(またはそのフラグメント)がインターネット上で有効な間に、その送信元・宛先の組とプロトコルとに対して一意な識別子を選択しなければならない。
送信側プロトコルモジュールは、識別子のテーブル(インターネットのためのそのパケットの最大ライフタイム内で、それが通信する各宛先ごとにひとつのエントリ)を保持する必要があるだろう。
しかしながら識別子フィールドは 65,536 の異なる値を取れるため、ホストによっては宛先に依存しない一意の識別子を単純に利用することができるだろう。
何らかの上位レベルプロトコルが識別子を選択するのが適切である。例えば TCP モジュールは同じ TCP セグメントを再送信してもよく、もし再送信で元の送信と同じ識別子が運ばれれば、どちらのデータグラムのフラグメントも正しい TCP セグメントを構築するために使用できるので、訂正を受け取る可能性が高められる。
サービス種別
サービス種別(TOS)はインターネットサービス品質の選択のためのものである。サービス種別は、抽象パラメータの優先順位(precedence)・遅延(delay)・スループット(throughput)・信頼性(reliability)にしたがって指定される。これらの抽象パラメータは、データグラムが通過する特定のネットワークの実際のサービスパラメータにマップされる。
優先順位(Precedence)。このデータグラムの重要度の独立した基準。
遅延(Delay)。この指定を持つデータグラムには迅速な配送が重要である。
スループット(Throughput)。この指定を持つデータグラムには高速のデータ転送速度が重要である。
信頼性(Reliability)。この指定を持つデータグラムには高水準の配送保証が重要である。
例えば ARPANET は優先順位ビットと、"standard" メッセージ(タイプ 0)および "uncontrolled" メッセージ(タイプ 3)の間の選択権とを持つ(シングルパケットメッセージとマルチパケットメッセージとの間の選択もサービスパラメータと考えることができる)。uncontrolled メッセージは、信頼性がより低く、遅延がより大きくなる傾向がある。インターネットデータグラムが ARPANET を通して送信されると仮定する。そのインターネットサービス種別を次のように与える：
      優先順位(Precedence):      5
      遅延(Delay):               0
      スループット(Throughput):  1
      信頼性(Reliability):       1

この例おいてこれらのパラメータから APRANET で有効なパラメータへのマッピングは、インターネット優先順位がその範囲の上半分であるため ARPANET 優先順位ビットをオンにセットすることになり、スループットおよび信頼性の要求が指定され遅延が指定されていないため標準メッセージを選択することになるだろう。詳細は "Service Mappings" [8] におけるサービスマッピングに示されている。
有効期間(Time to Live)
有効期間は送信者によって、そのデータグラムがインターネットシステム内に存在することを許される最大時間にセットされる。データグラムがこの有効期間を超えてインターネットシステムに存在した場合、そのデータグラムは破棄されなければならない。
データグラムの処理に費やされた時間を反映するために、このフィールドはインターネットヘッダが処理される場所ごとに減らされる。実際に費やされた時間に付いてのローカル情報が利用できない場合、このフィールドは 1 だけ減らされなければならない。この時間は秒単位で計測される(例えば値 1 は 1 秒を意味する)。したがって最大の有効期間は 255 秒、つまり 4.25 分となる。たとえデータグラムの処理を 1 秒未満で終えたとしても、データグラムを処理するすべてのモジュールは TTL を少なくとも 1 減らさなければならないため、TTL はデータグラムが存在する可能性のある時間の上限にすぎないと考えなければならない。この目的は、配送不能なデータグラムを破棄させ、データグラムの寿命を制限することである。
一部の上位レベルの信頼できる接続プロトコルは、古い重複したデータグラムが一定時間経過するまで到着しないという仮定に基づいている。TTL はそのようなプロトコルにその仮定が成立することを保障するための手段である。
オプション(Options)
オプションは各データグラムにおいて任意であるが、実装は必須である。つまりオプションの有無は送信者の選択であるが、各インターネットモジュールは全てのオプションを解析できなければならないということである。オプションフィールドには複数のオプションが現れてよい。
オプションは 32 ビット境界で終了しない可能性がある。インターネットヘッダの空き部分はオクテット 0 で埋められなければならない。それらの先頭は end-of-options オプションとして解釈され、その残りはインターネットヘッダのパディングとして解釈される。
すべてのインターネットモジュールは、すべてのオプションに基づいて動作可能でなければならない。機密扱いまたは制限された、または区画されたトラフィックを通過させる場合、Security Option が必要である。
チェックサム(Checksum)
インターネットヘッダが変更されると、インターネットヘッダチェックサムは再計算される。変更は例えば TTL の減少や、インターネットオプションの追加や変更、フラグメント化により行われる。このインターネットレベルのチェックサムは、インターネットヘッダフィールドの転送エラーを防ぐことを目的としている。
アプリケーションによっては、多少のビットエラーは受け入れられるが、再送遅延は受け入れられない場合がある。インターネットプロトコルに正確性が強制された場合、このようなアプリケーションはサポートされないだろう。
エラー(Errors)
インターネットプロトコルのエラーは ICMP メッセージ [3] によって報告されてよい。
3.3． インターフェイス
あらゆるオペレーティングシステムがさまざまな機能を持つため、IP に対するユーザーインターフェイスの機能的な説明は、よく言って作り話である。そのため私たちは読者に、異なる IP 実装は異なるユーザーインターフェイスを持つ可能性があることを警告しなければならない。しかしながら、すべての IP 実装が同じプロトコル階層をサポートできることを保証するために、すべての IP は最低限のサービス一式を提供しなければならない。このセクションは、すべての IP 実装に必須の機能インターフェイスを規定する。

インターネットプロトコルは、ローカルネットワーク側の一方と、上位レベルのプロトコルまたはアプリケーションプログラム側のもう一方とを接続する。上位レベルのプログラムまたはアプリケーションプログラム(またはたとえゲートウェイプログラムでも)はインターネットモジュールを使用(use)するため、以降それらを "ユーザー(user)" と呼ぶ。インターネットプロトコルはデータグラムプロトコルであり、データグラム転送の間に保持されるメモリと状態とは最小限であるため、ユーザーによるインターネットプロトコルモジュールの各呼び出しは、要求されたサービスを実行するのに IP が必要とするすべての情報を提供する。

上位レベルインターフェイスの例

以下の二つの呼び出しの例は、インターネットプロトコルモジュールの通信に対するユーザー要件を満たしている("=>" は戻りを意味する)：

  SEND (src, dst, prot, TOS, TTL, BufPTR, len, Id, DF, opt => result)
ここで：

      src = 送信元アドレス
      dst = 宛先アドレス
      prot = プロトコル
      TOS = サービス種別
      TTL = 有効期間
      BufPTR = バッファポインタ
      len = バッファ長
      Id  = 識別子
      DF = ドントフラグメント
      opt = オプション情報
      result = 応答
        OK = データグラム送信完了
        Error = 引数エラー、またはローカルネットワークエラー
優先順位は TOS の中に含まれ、セキュリティ/区分はオプションとして渡されることに注意してほしい。

  RECV (BufPTR, prot, => result, src, dst, TOS, len, opt)
ここで：

      BufPTR = バッファポインタ
      prot = プロトコル
      result = 応答
        OK = データグラム受信完了
        Error = 引数エラー
      len = バッファ長
      src = 送信元アドレス
      dst = 宛先アドレス
      TOS = サービス種別
      opt = オプション情報
ユーザーがデータグラムを送信するとき、すべての引数を提供する SEND 呼び出しを実行する。その呼び出しを受けてインターネットプロトコルモジュールは引数を確認し、メッセージを準備し、送信する。引数が正しく、かつデータグラムがローカルネットワークに受け入れられた場合、その呼び出しは成功を返す。引数が不正、またはデータグラムがローカルネットワークに受け入れられなかった場合、その呼び出しはし失敗を返す。失敗が返される場合、問題の原因についての適切な報告が行われなければならないが、その報告の詳細は個々の実装次第である。

ローカルネットワークからインターネットプロトコルモジュールにデータグラムが到着したとき、送信先のユーザーからの未解決の RECV 呼び出しが存在するか存在しないか、どちらかとなる。前者の場合、その未解決の呼び出しはその情報がデータグラムからユーザーに渡されることで解決される。後者の場合、送信先のユーザーは未解決のデータグラムを通知される。送信先のユーザーが存在しない場合、送信元に ICMP エラーメッセージが返され、データは破棄される。

ユーザーへの通知は、その実装の個々のオペレーティングシステム環境に応じて、擬似割り込みまたはそれに似たメカニズムであってもよい。

その後ユーザーの RECV 呼び出しは、未解決のデータグラムによって即座に解決されるか、データグラムの到着まで保留されてよい。

送信側ホストが複数のアドレスを持つ(複数の物理接続または論理接続を持つ)場合、送信呼び出しに送信元アドレスが含まれる。インターネットモジュールは、その送信元アドレスがそのホストの有効なアドレスのひとつであることを確認しなければならない。

また実装は、あるクラスのデータグラム(例えばプロトコルフィールド内にある特定の値を持つすべてのデータグラム)の排他的使用に興味があること、またはそれを予約することを示すために、インターネットモジュールの呼び出しを許可、または必要としてよい。

このセクションは USER/IP インターフェイスの機能的特性を明らかにする。使用される表記法は高水準言語における関数呼び出しの手順に似ているが、この使用法はトラップ型のサービスコール(例えば SVC・UUO・EMT)、または他の形式のプロセス間通信を除外することを意図したものではない。

付録 A：例とシナリオ
例 1：
これはインターネットデータグラムを運ぶ最小限のデータの例である。

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Ver= 4 |IHL= 5 | サービス種別  |            全長 = 21          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          識別子 = 111         |Flg=0|フラグメントオフセット=0 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   時間 = 123  |プロトコル = 1 |      ヘッダチェックサム       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         送信元アドレス                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          宛先アドレス                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    データ     |
   +-+-+-+-+-+-+-+-+

                     インターネットデータグラムの例

                                 図 5.
各目盛りが 1 ビットを表していることに注意してほしい。

これは IPv4 のインターネットデータグラムであり、インターネットヘッダは 32 ビットワードの 5 ワードから成り、データグラムの全長は 21 オクテットである。このデータグラムは完結したデータグラムである(つまりフラグメントではない)。

例 2：
この例において私たちは、最初に中程度のサイズのインターネットデータグラム(452 データオクテット)を示す。次に、許可される最大転送サイズが 280 オクテットの場合に、そのデータオクテットのフラグメント化から生じるであろう二つのインターネットフラグメントを示す。

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Ver= 4 |IHL= 5 | サービス種別  |            全長 = 472         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         識別子 = 111          |Flg=0|フラグメントオフセット=0 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   時間 = 123  |プロトコル = 6 |      ヘッダチェックサム       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         送信元アドレス                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          宛先アドレス                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                            データ                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                            データ                             |
   /                                                               /
   /                                                               /
   |                            データ                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |            データ             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                     インターネットデータグラムの例

                                 図 6.
次にこのデータグラムを 256 データオクテットで分割して生じるひとつ目のフラグメントを示す。

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Ver= 4 |IHL= 5 | サービス種別  |            全長 = 276         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          識別子 = 111         |Flg=1|フラグメントオフセット=0 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   時間 = 119  |プロトコル = 6 |      ヘッダチェックサム       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         送信元アドレス                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          宛先アドレス                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                            データ                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                            データ                             |
   /                                                               /
   /                                                               /
   |                            データ                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                            データ                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                     インターネットフラグメントの例

                                 図 7.
次に二番目のフラグメントを示す。

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Ver= 4 |IHL= 5 | サービス種別  |            全長 = 216         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          識別子 = 111         |Flg=0|フラグメントオフセット=32|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   時間 = 119  |プロトコル = 6 |      ヘッダチェックサム       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         送信元アドレス                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          宛先アドレス                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                            データ                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                            データ                             |
   /                                                               /
   /                                                               /
   |                            データ                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           データ              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                     インターネットフラグメントの例

                                 図 8.
例 3：
オプションを含むデータグラムの例を示す：

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Ver= 4 |IHL= 8 | サービス種別  |            全長 = 576         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          識別子 = 111         |Flg=0|フラグメントオフセット=0 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   時間 = 123  |プロトコル = 6 |      ヘッダチェックサム       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        送信元アドレス                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         宛先アドレス                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Opt. Code = x | Opt.  Len.= 3 | オプション値  | Opt. Code = x |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Opt. Len. = 4 |           オプション値        | Opt. Code = 1 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Opt. Code = y | Opt. Len. = 3 |  オプション値 | Opt. Code = 0 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                            データ                             |
   /                                                               /
   /                                                               /
   |                            データ                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                            データ                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                     インターネットデータグラムの例

                                 図 9.
付録 B： データ転送順序
この文書で説明されているヘッダとデータとの転送順序は、オクテットレベルまで決定される。データグラムがオクテットの組を表すとき、それらのオクテットの転送順序は常に通常英語で読まれる場合の順序となる。例えば以下のデータグラムにおいて、各オクテットは番号付けされた順序で転送される。

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |       1       |       2       |       3       |       4       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |       5       |       6       |       7       |       8       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |       9       |      10       |      11       |      12       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                            バイトの転送順序

                                 図 10.
オクテットが数量を表す場合、常に図の最左ビットが高位または最上位ビットである。つまり、ラベル 0 のビットが最上位ビットである。例えば以下の図は値 170(10 進数) を表す。

                            0 1 2 3 4 5 6 7
                           +-+-+-+-+-+-+-+-+
                           |1 0 1 0 1 0 1 0|
                           +-+-+-+-+-+-+-+-+

                              ビットの重み

                                 図 11.
同じように複数オクテットのフィールドが数量を表す場合、常にそのフィールド全体の最左ビットが最上位ビットとなる。複数オクテットの数値が転送されるとき、最上位ビットから先に転送される。

用語集
1822
BBN Report 1822, "The Specification of the Interconnection of a Host and an IMP"。ホストと ARPANET との間のインターフェイス仕様。
ARPANET リーダー (ARPANET leader)
ホスト-IMP 間のンターフェイスにおける ARPANET 上の制御情報。
ARPANET メッセージ (ARPANET message)
ARPANET におけるホストと IMP との間の通信単位。最大サイズはおよそ 1012 オクテット(8096 ビット)である。
ARPANET パケット (ARPANET packet)
IMP 間において ARPANET 内で内部的に使用される通信単位。最大サイズはおよそ 126 オクテット(1008 ビット)である。
宛先(Destination)
インターネットヘッダフィールドの宛先アドレス
DF
フラグフィールド内で運ばれるドントフラグメントビット。
フラグ(Flags)
さまざまな制御フラグを運ぶインターネットヘッダフィールド。
フラグメントオフセット(Fragment Offset)
このインターネットヘッダフィールドは、インターネットデータグラムの中でフラグメントの占める位置を表す。
GGP
Gateway to Gateway Protocol。このプロトコルは、ルーティングと他のゲートウェイ機能とを制御するために、主にゲートウェイ間で使用される。
ヘッダ(header)
メッセージやセグメント、データグラム、パケット、データブロックなどの先頭に置かれる制御情報。
ICMP
Internet Control Message Protocol。インターネットモジュール内に実装される。ICMP はエラーの報告とルーティングの指示とを行うために、ゲートウェイからホストへ、またはホスト間で使用される。
識別子(Identification)
データグラムのフラグメントを組み立てる手助けとなるように送信者によって割り当てられる識別子を運ぶインターネットヘッダフィールド。
IHL
インターネットヘッダフィールド Internet Header Length は、インターネットヘッダの 32 ビットワード単位の長さである。
IMP
Interface Message Processor。ARPANET のパケットスイッチ。
インターネットアドレス(Internet Address)
Network フィールドと Local Address フィールドとを構成する 4 オクテット(32 ビット)の送信元または宛先アドレス。
インターネットデータグラム(internet datagram)
インターネットモジュールの組の間で交換されるデータの構成単位(インターネットヘッダを含む)。
インターネットフラグメント(internet fragment)
インターネットヘッダを持つインターネットデータグラムのデータの一部分。
ローカルアドレス(Local Address)
ネットワークの内側のホストのアドレス。インターネットローカルアドレスからネットワーク内のホストアドレスへの実際のマッピングは極めて一般的であり、多対一のマッピングも許される。
MF
インターネットヘッダのフラグフィールド内で運ばれるモアフラグメントフラグ(More-Fragments Flag)。
モジュール(module)
プロトコルまたは他の手続きの(通常はソフトウェアによる)実装。
モアフラグメントフラグ(more-fragments flag)
このインターネットデータグラムがインターネットデータグラムの終端を含むかどうかを表すフラグ。インターネットヘッダのフラグフィールド内で運ばれる。
NFB
インターネットフラグメントのデータ部におけるフラグメントブロック数。つまり、データ部の長さの 8 オクテット単位の長さ。
オクテット(octet)
8 ビットバイト。
オプション(Options)
インターネットヘッダのオプションフィールドは複数のオプションを含むことが許され、各オプションは複数オクテット長でもよい。
パディング(Padding)
インターネットヘッダのパディングフィールドは、データが 32 ビットワード境界から始まることを保証するために使用される。パディングはゼロである。
プロトコル(Protocol)
この文書においては、次の上位レベルプロトコル識別子。インターネットヘッダフィールド。
Rest
インターネットアドレスのローカルアドレス部。
送信元(Source)
送信元アドレス。インターネットヘッダフィールド。
TCP
Transmission Control Protocol：インターネット環境における信頼できる通信のためのホスト間プロトコル。
TCP セグメント (TCP Segment)
TCP モジュール間で交換されるデータの構成単位(TCP ヘッダを含む)。
TFTP
Trivial File Transfer Protocol：UDP 上に構築される単純なファイル転送プロトコル。
有効期間(Time to Live)
このインターネットデータグラムが存在してよい時間の上限を表すインターネットヘッダフィールド。
TOS
サービス種別(Type of Service)。
全長(Total Length)
インターネットヘッダフィールドである全長(Total Length)は、インターネットヘッダとデータとを含むデータグラムのオクテット単位の長さである。
TTL
有効期間(Time to Live)
サービス種別(Type of Service)
このインターネットデータグラムのためのサービスの種別(または品質)を表すインターネットヘッダフィールド。
UDP
User Datagram Protocol：トランザクション指向アプリケーションのためのユーザーレベルプロトコル。
ユーザー(User)
インターネットプロトコルのユーザー。これは上位レベルのプロトコルモジュール、またはアプリケーションプログラム、ゲートウェイプログラムの可能性がある。
バージョン(Version)
バージョンフィールドはインターネットヘッダのフォーマットを表す。
参考資料
[1] Cerf, V., "The Catenet Model for Internetworking," Information Processing Techniques Office, Defense Advanced Research Projects Agency, IEN 48, July 1978.

[2] Bolt Beranek and Newman, "Specification for the Interconnection of a Host and an IMP," BBN Technical Report 1822, Revised May 1978.

[3] Postel, J., "Internet Control Message Protocol - DARPA Internet Program Protocol Specification," RFC 792, USC/Information Sciences Institute, September 1981.

[4] Shoch, J., "Inter-Network Naming, Addressing, and Routing," COMPCON, IEEE Computer Society, Fall 1978.

[5] Postel, J., "Address Mappings," RFC 796, USC/Information Sciences Institute, September 1981.

[6] Shoch, J., "Packet Fragmentation in Inter-Network Protocols," Computer Networks, v. 3, n. 1, February 1979.

[7] Strazisar, V., "How to Build a Gateway", IEN 109, Bolt Beranek and Newman, August 1979.

[8] Postel, J., "Service Mappings," RFC 795, USC/Information Sciences Institute, September 1981.

[9] Postel, J., "Assigned Numbers," RFC 790, USC/Information Sciences Institute, September 1981.

トップページ - 翻訳ドキュメント - RFC 791